# -*- coding: utf-8 -*-
"""Regra_de_Cramer_por_Laplace.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rmKvOiuDDvd41KFVDNVAzsdBQy7lIg-A
"""

from copy import deepcopy
import timeit
import numpy as np

n = 8

def zeros_matrix(rows, cols):
    M = []
    while len(M) < rows:
        M.append([])
        while len(M[-1]) < cols:
            M[-1].append(0.0)

    return M

def copy_matrix(M):
    rows = len(M)
    cols = len(M[0])

    MC = zeros_matrix(rows, cols)

    for i in range(rows):
        for j in range(cols):
            MC[i][j] = M[i][j]

    return MC   

def laplace(A):
    det = 0 #Inicializa o determinante com 0
    col = [] #Inicializa um vetor de indice de colunas vazio

    for i in range(len(A)): #colunas = list(range(len(A))) # Armazena em uma lista as colunas de A
        col.append(i)
    
    if len(A) == 1 and len(A[0]) == 1:
        return A[1][1]  # Excessao, matriz unitaria 
    elif len(A) == 2 and len(A[0]) == 2:    # Caso Base Recursivo : Resolver um determinante 2x2 
        det = A[0][0] * A[1][1] - A[1][0] * A[0][1]
        return det
    else:
    #Caso Geral: 
        for j in col: # Para cada coluna de cada indice da lista

            M = copy_matrix(A) #Faz uma copia exata da Matriz A e atribui a M
            M = M[1:] # Remove a linha a primeira linha da Matriz M
 
            for i in range(len(M)): # para i de 0 até o tamanho da matriz M
                M[i] = M[i][0:j] + M[i][j+1:] #Remove os elementos da coluna focal do cofator atual
             # Se a coluna do cofator for par, o sinal é positivo. Caso contrário, negativo. 
            
            det += ((-1) ** (j % 2) * A[0][j] * laplace(M)) # Acumula o determinante das chamadas recursivas
    
        return det #retorna o somatório de todas as chamadas recursivas e o tempo de execucao

def Vandermonde(n):
    V = np.zeros([n,n])
    for i in range(n): 
        for j in range(n):
            V[i,j] = (j+1)**i
    return V

def Cauchy(n):
    x = np.arange(1,n+1)
    y = x - 0.5
    C = np.zeros([n,n])
    for i in range (0, len(x)):
        for j in range ( 0, len(y)): 
            C[i,j] = 1.0 / ( x[i] - y[j] )
    return C

def Hilbert(n):
    H = np.zeros([n,n])
    for i in range(0, n):
        for j in range(0, n):
            H[i,j] = 1/(i + 1 + j + 1 - 1)
    return H

def Toeplitz(n):
    T = np.zeros([n,n])
    for i in range(n):
      for j in range(n):
            if i == j:
                T[i][j] = n*n
            else:
                T[i][j] = i-j
            if j>i:
                T[i][j] = -T[i][j]
    return T

def Cramer(A,b,n) :
    d = np.zeros(n)
    X = np.zeros(n)

    inicio = timeit.default_timer()
    for j in range(n) :
        M = deepcopy(A)
        for i in range(n):
            M[i,j] = b[i]
        
        d[j] = laplace(M)
        X[j] = d[j]/laplace(A)
    fim = timeit.default_timer()
    tempo = fim - inicio
    return X, tempo

def b(A,n):
    b = np.empty(n)
    b.fill(1)
    b = A.dot(b)
    return b

def Printar_Matriz(A, n):
    A = np.copy(A)
    print("|================================================   A  =========================================================")
    print()
    for i in range(n):
        for j in range(n):
            print(f'[{A[i,j]:^12.5}]', end ='')
        print()
    print()
    print("================================================================================================================")
    for i in range(0,3):
        print("")

def Printar_b(b):
    print("=================================")
    for i in range(n):
        print("b" + str(i+1) + " = " +f'[{b[i]:^15}]', end ='')
        print()
    print()

def Printar_X(X):
    print()
    print("=================================")
    for i in range(n):
        print("X" + str(i+1) + " = " +f'[{X[i]:^15}]', end ='')
        print()
    print()

def eqm(X, n):
    b = np.empty(n)
    b.fill(1)
    X = np.copy(X)
    eqm = 0
    for i in range(n):
        eqm = eqm + abs(b[i]-X[i]) * abs(b[i]-X[i])
    eqm = eqm/n
    return eqm

def Printar_Tempo (tempo):

    print("=============================")
    print('Tempo: %f' % (tempo) +' segundos')
    print("=============================")

def Printar_Determinante (det):
    for i in range(0,5):
        print()
    print("=====================================")
    print('Determinante:' + str(det))
    print("=====================================")
    print()

def Printar_Tempo (tempo):
    print("=============================")
    print('Tempo: %f' % (tempo) +' segundos')
    print("=============================")

C = Cauchy(n)
#H = Hilbert(n)
#V = Vandermonde(n)
#T = Toeplitz(n)

b = b(C,n)
#inicio = timeit.default_timer()
#det = laplace(C)
#fim = timeit.default_timer()
#tempo = fim - inicio
#Printar_Determinante(det)
#Printar_Tempo (tempo)

Printar_Matriz(C,n)

#Printar_b(b)

X, tempo = Cramer(C, b, n)

Printar_X(X)
Printar_Tempo(tempo)

print("O erro quadrático médio é: " + str(eqm(X, n)))